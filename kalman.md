# The Extended Kalman Filter: An Interactive Tutorial for Non-Experts

网址:<https://home.wlu.edu/~levys/kalman_tutorial/>



# Part 1: A Simple Example

想象一架飞机降落的飞机。 虽然我们可能会担心很多事情，比如空速，燃料等，但最明显的事情是关注飞机的高度（海拔高度）。 作为一个非常简单的近似，我们可以将当前高度视为先前高度的一部分。 例如，如果飞机每次观察时失去2％的高度，那么当前时间的高度是前一时间高度的98％：
$$
altitude_{current\_time} = 0.98 * altitude_{previous\_time}
$$


工程师使用递归这个术语来指代这样的公式，其中数量是根据其先前值定义的：要计算当前值，我们必须“重复”回到之前的值。 最终我们重新回到一些初始的“基本情况”，就像一个已知的起始高度。

# Part 2: Dealing with Noise

当然，诸如高度之类的真实世界测量值是从诸如GPS或气压计之类的传感器获得的。 这种传感器提供不同程度的准确度。 [2]如果传感器关闭了恒定量，我们可以简单地增加或减去该数量以确定我们的高度。 但是，通常情况下，传感器精度会随时变化，使观察到的传感器读取真实高度的“嘈杂”版本：
$$
observed\_altitude_{current_time}=altitude_{current\_time}+noise_{current\_time}
$$

# Part 3: Putting it Together

所以现在我们有两个描述我们飞机状态的方程式：
$$
altitude_{current\_time} = 0.98 * altitude_{previous\_time}\\
observed\_altitude_{current_time}=altitude_{current\_time}+noise_{current\_time}
$$
这些方程很容易理解，但它们不足以处理除飞机高度示例之外的系统。 为了使方程更通用，工程师采用了熟悉的数学约定，即使用$x$，$y$和$z$等名称作为变量，$a$和$b$作为常数，下标$k$表示时间。[3] 所以我们的方程变为：
$$
x_k=ax_{k-1}\\
z_k=x_k+v_k
$$
其中$x$是我们系统的当前状态，$x_{k-1}$是它的先前状态，$a$是一些常数（在我们的例子中是0.98），$z_k$是我们当前对系统的观察，而$v_k$是当前的噪声测量。 卡尔曼滤波器如此受欢迎的一个原因是它允许我们在给定观测值$z_k$，常数$a$和测量噪声的总量$v$的情况下得到对实际当前状态$x_k$的非常好的估计。

为了完成图片，我们还应该考虑到飞机的实际高度可能无法描述完美平滑的路径。 任何飞过的人都可以告诉你，飞机降落时通常会遇到一定程度的湍流。 根据定义，这种湍流是嘈杂的，因此可以将其视为另一种噪声信号：
$$
altitude_{current\_time} = 0.98 * altitude_{previous\_time}+turbulence_{current\_time}
$$
更通用的公式为:
$$
x_k=ax_{k-1}+w_k
$$
其中$w_k$被称为过程噪声，因为它像湍流一样，是过程的固有部分，而不是观察或测量的人为因素。 我们将忽略过程噪声一段时间以便专注于其他主题，但我们将在传感器融合部分回到它。[4]

# Part 4: State Estimation

这里再次（忽略过程噪声）是我们描述我们正在观察的系统状态的两个等式：
$$
x_k=ax_{k-1}+w_k\\
z_k=x_k+v_k
$$
由于我们的目标是从观测值z获得状态x，我们可以将第二个等式重写为：
$$
x_k=z_k-v_k
$$
问题当然是我们不知道当前的噪音$v_k$：根据定义它是不可预测的。 幸运的是，卡尔曼认为我们可以通过考虑当前观察和先前估计的状态来估计状态。 工程师在变量上使用一点插入符号或“帽子”来表示它是估计的：所以$\hat{x}_k$是当前状态的估计值。 然后，我们可以将估计值表示为先前估计值与当前观测值之间的权衡：


$$
\hat{x}=\hat{x}_{k-1}+g_k(z_k-\hat{x}_{k-1})
$$


其中g是表示权衡的“增益”术语。[5] 我用红色突出显示了这个等式，因为它是我们将直接用于实现卡尔曼滤波器的方程式。
现在，这看起来相当复杂，但想想增益gk的两个极值会发生什么。 对于 $g_k= 0$，我们得到
$$
\hat{x}=\hat{x}_{k-1}+0(z_k-\hat{x}_{k-1})
$$
换句话说，当增益为零时，观察没有效果，我们得到将当前状态与前一状态相关的原始方程。 对于$g_k=1$，我们得到

$$
\hat{x}=\hat{x}_{k-1}+1(z_k-\hat{x}_{k-1})=\hat{x}=\hat{x}_{k-1}+z_k-\hat{x}_{k-1}=z_k
$$

当然，实际增益值可能会介于这两个极端之间。



# Part 5: Computing the Gain

所以现在我们有一个公式，我们可以实际用于根据先前估计$\hat{x}_{k-1}$，当前观测值$z_k$和当前增益$g_k$计算当前状态估计值$\hat{x}_k$:

$$
\hat{x}=\hat{x}_{k-1}+g_k(z_k-\hat{x}_{k-1})
$$
那么我们如何计算增益呢？ 答案是：间接地，通过噪音。 回想一下，每个观察都与特定的噪声值相关联：
$$
z_k=x_k+v_k
$$
我们不知道观察的个体噪声值，但我们通常知道平均噪声：例如，传感器的公布精度告诉我们输出的噪声大小。 称此值为$r$; 它没有下标，因为它不依赖于时间，而是传感器的属性。 然后我们可以用$r$计算当前增益$g_k$：
$$
g_k=p_{k-1}/(p_{k-1}+r)
$$
其中$p_k$是递归计算的预测误差：[6]
$$
p_k=(1-g_k)p_{k-1}
$$
与状态估计公式一样，让我们在继续之前考虑这两个公式的含义。

假设我们先前预测的误差$p_{k-1}$为零。那么我们当前的增益$g_k$将是$0/(0+r)=0$，我们的下一个状态估计与我们当前的状态估计没有什么不同。这是有道理的，因为如果我们的预测是准确的，我们就不应该调整我们的状态估计。在另一个极端，说预测错误是一个。然后增益为$1/(1+r)$。如果$r$为零---即，如果我们的系统中的噪声很小 - 则增益将为1，并且我们的新状态估计$x_k$将受到我们的观测$z_k$的强烈影响。但随着$r$变大，增益可能变得任意小。换句话说，当系统足够嘈杂时，必须忽略不良预测。噪音克服了我们纠正错误预测的能力。

那么第三个公式呢，从它先前的值$p_{k-1}$和当前的增益$g_k$？递归地计算预测误差$p_k$？同样，它有助于思考增益的极值会发生什么：当$g_k=0$时，我们有$p_k=p_{k-1}$。因此，与状态估计一样，零增益意味着不会更新预测误差。另一方面，当$g_k=1$时，我们有$p_k=0$。因此，最大增益对应于零预测误差，仅用当前观察来更新当前状态。

----

[6]技术上，r实际上是噪声信号的方差; 即，各个噪声值与其平均值的扩展或平方平均距离。 如果允许这种噪声方差随时间变化，卡尔曼滤波器将同样有效，但在大多数应用中，它可以假定为常数。 同样地，pk在技术上是步骤k的估计过程的协方差; 它是我们预测的平方误差的平均值。 实际上，正如Tim Wilkin向我指出的那样，状态是一个随机的[随机变量]变量/向量（随机过程的瞬时值），它根本没有“真实”值！ 估计值仅仅是描述状态的过程模型的最可能值。

# Part 6: Prediction and Update

我们几乎准备好运行我们的卡尔曼滤波器并看到一些结果。 首先，您可能想知道我们原始状态方程中的常数$a$发生了什么：
$$
x_k=ax_{k-1}
$$
这似乎在我们的状态估计等式中消失了：
$$
\hat{x}=\hat{x}_{k-1}+g_k(z_k-\hat{x}_{k-1})
$$
答案是，我们需要这两个方程来估计状态。 实际上，两个方程都代表了基于不同类型信息的状态估计。 我们的原始方程表示关于状态应该是什么的预测，并且我们的第二方程表示基于观察的该预测的更新。 [7]因此我们用$x$上的小帽子重写原始方程以表示估计：
$$
x_k=ax_{k-1}
$$
最后，我们也使用常数$a$来预测误差：[8]
$$
p_k=ap_{k-1}a
$$
这两个红色公式(18,19)一起代表卡尔曼滤波器的预测阶段。 我们的想法是循环预测/更新，预测/更新.....重复我们想要的次数。

---

[7]从技术上讲，第一个估计称为先验，后者称为后验，大多数处理引入一些额外的上标或下标来表示区别。 因为我试图保持简单（并且易于使用您喜欢的编程语言编写代码！），所以我避免将符号复杂化。

[8]正如张子超向我指出的那样，我们乘以两次是因为预测误差$p_k$本身就是一个平方误差; 因此，它通过与状态值$x_k$相关联的系数的平方来缩放。 在第12部分中，将错误预测表示为$ap_{k-1}a$而不是$a^2p_{k-1}$的原因将变得清晰。

# Part 7: Running the Filter

所以现在我们拥有运行卡尔曼滤波器所需的一切：

**预测:**
$$
x_k=ax_{k-1}\\
p_k=ap_{k-1}a\\
$$
**更新:**
$$
g_k=p_k/(p_k+r)\\
\hat{x}_k \leftarrow \hat{x}_k+g_k(z_k-\hat{x}_k)\\
p_k\leftarrow(1-g_k)p_k
$$
请注意，我在更新的最后两行中使用了赋值（箭头）符号，而不是标准等号。 尽管这种用法是非传统的，但它得出的结论是对$\hat{x}_k$和$p_k$的更新正在修改它们的当前值（来自预测步骤），而不是根据前一步骤定义这些值（如预测那样）。[9]



要试用我们的过滤器，我们需要：

- 一系列观察zk
- 状态估计的初始值（基本情况）x ^ 0。 这可能只是我们的第一次观察z0。
- 预测误差的初始值p0。 它不能为0，否则pk会通过乘法永远保持0。 所以我们任意设置为1。

对于我们的观测，我们不是试图观察一个实际的系统（就像进入着陆的平面），而是基于在区间[-200，+ 200]中添加随机噪声[10] vk来伪造一些观测值。 理想值xk = 0.75xk-1，从x0 = 1000开始：